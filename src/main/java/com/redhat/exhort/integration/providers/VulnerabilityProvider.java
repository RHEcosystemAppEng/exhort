/*
 * Copyright 2023 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.redhat.exhort.integration.providers;

import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.camel.Exchange;
import org.apache.camel.ExchangeProperty;
import org.apache.camel.Headers;
import org.apache.camel.util.URISupport;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import com.redhat.exhort.integration.Constants;

import io.quarkus.runtime.annotations.RegisterForReflection;

import jakarta.annotation.PostConstruct;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.ClientErrorException;

@ApplicationScoped
@RegisterForReflection
public class VulnerabilityProvider {

  @ConfigProperty(name = "api.snyk.disabled", defaultValue = "false")
  boolean snykDisabled;

  @ConfigProperty(name = "api.ossindex.disabled", defaultValue = "false")
  boolean ossIndexDisabled;

  private List<String> providers;

  @PostConstruct
  public void initProviders() {
    providers =
        Collections.unmodifiableList(
            Constants.PROVIDERS.stream()
                .filter(p -> !(Constants.SNYK_PROVIDER.equals(p) && snykDisabled))
                .filter(p -> !(Constants.OSS_INDEX_PROVIDER.equals(p) && ossIndexDisabled))
                .toList());
  }

  public String get(@ExchangeProperty(Exchange.MULTICAST_INDEX) int index) {
    return providers.get(index);
  }

  public List<String> getProviderEndpoints(
      @ExchangeProperty(Constants.PROVIDERS_PARAM) List<String> providers) {
    return providers.stream()
        .map(
            p -> {
              switch (p) {
                case Constants.SNYK_PROVIDER:
                  return "direct:snykDepGraph";
                case Constants.OSS_INDEX_PROVIDER:
                  return "direct:ossIndexScan";
                default:
                  throw new IllegalArgumentException("Unexpected provider: " + p);
              }
            })
        .collect(Collectors.toList());
  }

  public List<String> getEnabled() {
    return providers;
  }

  public List<String> getProvidersFromQueryParam(@Headers Map<String, String> headers)
      throws URISyntaxException {
    String query = headers.get(Exchange.HTTP_QUERY);
    Map<String, Object> props = URISupport.parseQuery(query);
    List<String> providers = getProviders(props);
    if (providers == null || providers.isEmpty()) {
      return getEnabled().stream().filter(p -> filterByAuthHeaders(p, headers)).toList();
    }
    List<String> missing =
        providers.stream()
            .filter(Predicate.not(p -> getEnabled().contains(p)))
            .collect(Collectors.toList());
    if (missing.isEmpty()) {
      return providers;
    }
    throw new ClientErrorException("Unsupported providers: " + missing, 422);
  }

  @SuppressWarnings("unchecked")
  private List<String> getProviders(Map<String, Object> props) {
    Object o = props.get(Constants.PROVIDERS_PARAM);
    if (o == null) {
      return null;
    }
    if (o instanceof String) {
      return List.of((String) o);
    }
    if (o instanceof List) {
      return (List<String>) o;
    }
    throw new ClientErrorException("Unsupported providers: " + o, 422);
  }

  @SuppressWarnings("unchecked")
  public void addProviderPrivateData(Exchange exchange, String provider) {
    List<String> current =
        (List<String>) exchange.getProperty(Constants.PROVIDER_PRIVATE_DATA_PROPERTY);
    if (current == null) {
      current = List.of(provider);
    } else {
      current = new ArrayList<>(current);
      current.add(provider);
    }
    exchange.setProperty(
        Constants.PROVIDER_PRIVATE_DATA_PROPERTY, Collections.unmodifiableList(current));
  }

  private boolean filterByAuthHeaders(String provider, Map<String, String> headers) {
    if (headers == null || headers.isEmpty()) {
      return true;
    }
    switch (provider) {
      case Constants.OSS_INDEX_PROVIDER:
        return headers.containsKey(Constants.OSS_INDEX_USER_HEADER)
            && headers.containsKey(Constants.OSS_INDEX_TOKEN_HEADER);
    }
    return true;
  }
}
